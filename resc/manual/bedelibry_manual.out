\BOOKMARK [0][-]{chapter.1}{Introduction}{}% 1
\BOOKMARK [1][-]{section.1.1}{Organization\040of\040this\040book}{chapter.1}% 2
\BOOKMARK [1][-]{section.1.2}{Getting\040started\040with\040Bedelibry\040Prolog}{chapter.1}% 3
\BOOKMARK [0][-]{chapter.2}{Logic\040Programming}{}% 4
\BOOKMARK [1][-]{section.2.1}{Facts\040and\040rules}{chapter.2}% 5
\BOOKMARK [1][-]{section.2.2}{Types}{chapter.2}% 6
\BOOKMARK [2][-]{subsection.2.2.1}{Open\040and\040closed\040types/relations}{section.2.2}% 7
\BOOKMARK [1][-]{section.2.3}{Assertions}{chapter.2}% 8
\BOOKMARK [1][-]{section.2.4}{Metainterpreters}{chapter.2}% 9
\BOOKMARK [0][-]{chapter.3}{Functional\040Programming}{}% 10
\BOOKMARK [1][-]{section.3.1}{Algebraic\040data\040types}{chapter.3}% 11
\BOOKMARK [1][-]{section.3.2}{Aside:\040Datatypes\040v.s.\040Entities\040in\040Bedelibry}{chapter.3}% 12
\BOOKMARK [1][-]{section.3.3}{Structural\040types}{chapter.3}% 13
\BOOKMARK [1][-]{section.3.4}{Parametric\040Polymorphism}{chapter.3}% 14
\BOOKMARK [0][-]{chapter.4}{Imperative\040and\040Object-Oriented\040Programming}{}% 15
\BOOKMARK [1][-]{section.4.1}{Imperative\040programming\040in\040Haskell}{chapter.4}% 16
\BOOKMARK [1][-]{section.4.2}{Bedelibry\040Prolog's\040Permission\040system}{chapter.4}% 17
\BOOKMARK [1][-]{section.4.3}{Inheritance\040in\040Bedelibry}{chapter.4}% 18
\BOOKMARK [0][-]{chapter.5}{Bedelibry}{}% 19
\BOOKMARK [1][-]{section.5.1}{Syntax}{chapter.5}% 20
\BOOKMARK [1][-]{section.5.2}{Dealing\040with\040ambiguity}{chapter.5}% 21
\BOOKMARK [2][-]{subsection.5.2.1}{Fuzzy\040concepts}{section.5.2}% 22
\BOOKMARK [2][-]{subsection.5.2.2}{Sense\040disambiguation}{section.5.2}% 23
\BOOKMARK [2][-]{subsection.5.2.3}{Lambek\040Types}{section.5.2}% 24
\BOOKMARK [2][-]{subsection.5.2.4}{Case\040study:\040Research\040notes}{section.5.2}% 25
\BOOKMARK [2][-]{subsection.5.2.5}{Case\040study:\040Random\040quotation\040generator}{section.5.2}% 26
